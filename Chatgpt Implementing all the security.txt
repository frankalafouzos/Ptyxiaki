Implementing all the security and user experience enhancements for your application is quite extensive and would involve significant changes to both your frontend and backend code. Here, I'll provide you with an outline and code snippets to guide you through this process. You'll need to integrate these into your existing codebase.

### Backend Enhancements

1. **JWT Middleware for Protected Routes:**
   ```javascript
   const jwt = require('jsonwebtoken');
   const expressJwt = require('express-jwt');

   const checkJwt = expressJwt({ secret: process.env.JWT_SECRET, algorithms: ['HS256'] });

   // Example of using this middleware
   router.get('/protected-route', checkJwt, (req, res) => {
     // Your protected route logic
   });
   ```

2. **CSRF Protection:**
   ```javascript
   const csurf = require('csurf');
   const csrfProtection = csurf({ cookie: true });

   // Apply CSRF protection to all routes
   app.use(csrfProtection);

   // In your routes, send the CSRF token back to the client
   router.get('/form', (req, res) => {
     res.json({ csrfToken: req.csrfToken() });
   });
   ```

### Frontend Enhancements

1. **React Router and Protected Routes:**
   ```jsx
   import { BrowserRouter as Router, Route, Switch, Redirect } from 'react-router-dom';

   const PrivateRoute = ({ component: Component, ...rest }) => (
     <Route {...rest} render={(props) => (
       isAuthenticated() ? <Component {...props} /> : <Redirect to='/login' />
     )} />
   );

   const App = () => (
     <Router>
       <Switch>
         <PrivateRoute path="/protected" component={ProtectedComponent} />
         <Route path="/login" component={Login} />
         // Other routes...
       </Switch>
     </Router>
   );
   ```

2. **Using Context API for Authentication State:**
   ```jsx
   const AuthContext = React.createContext();

   const AuthProvider = ({ children }) => {
     const [authState, setAuthState] = useState(null);

     const login = (userData) => {
       // Implement login logic and update authState
     };

     const logout = () => {
       // Implement logout logic and update authState
     };

     return (
       <AuthContext.Provider value={{ authState, login, logout }}>
         {children}
       </AuthContext.Provider>
     );
   };

   // Wrap your App component with AuthProvider in the index.js
   ```

3. **Toasts for Feedback:**
   Install a library like `react-toastify`:
   ```bash
   npm install react-toastify
   ```
   Then use it in your components for feedback:
   ```jsx
   import { toast } from 'react-toastify';

   toast.success("Login successful");
   toast.error("Login failed");
   ```

4. **Sending CSRF Token in Requests:**
   When making a POST request, include the CSRF token in your headers:
   ```javascript
   fetch('/submit-form', {
     method: 'POST',
     headers: {
       'Content-Type': 'application/json',
       'CSRF-Token': csrfToken // Get this token from your server
     },
     body: JSON.stringify(formData)
   });
   ```

### General Considerations
- Ensure your `JWT_SECRET` is securely stored and not hardcoded.
- Apply HTTPS in your production environment.
- Always validate and sanitize user inputs both on the client and server sides.
- Regularly update your dependencies to their latest versions for security patches.

Implementing these features will greatly enhance the security and usability of your application. Note that you'll need to integrate these snippets with your existing code and make adjustments as necessary to fit your application's architecture and requirements.